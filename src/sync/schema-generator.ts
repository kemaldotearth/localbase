import type {
  TableSchema,
  ExtendedTableSchema,
  ColumnDefinition,
} from "../types";

/**
 * Maps common TypeScript/JavaScript types to PostgreSQL types
 */
const TYPE_MAP: Record<string, string> = {
  string: "text",
  number: "numeric",
  boolean: "boolean",
  date: "timestamptz",
  json: "jsonb",
  array: "jsonb",
  uuid: "uuid",
  bigint: "bigint",
  integer: "integer",
  text: "text",
  timestamptz: "timestamptz",
  timestamp: "timestamp",
};

/**
 * Generates a PostgreSQL column definition from a ColumnDefinition
 */
function generateColumnDef(
  columnName: string,
  def: ColumnDefinition | string
): string {
  if (typeof def === "string") {
    // If it's already a raw SQL type definition, use it directly
    return `"${columnName}" ${def}`;
  }

  const parts: string[] = [`"${columnName}"`];

  // Map type
  const pgType = TYPE_MAP[def.type.toLowerCase()] || def.type;
  parts.push(pgType);

  // Primary key
  if (def.primaryKey) {
    if (def.generated) {
      parts.push("primary key generated always as identity");
    } else {
      parts.push("primary key");
    }
  }

  // Nullable
  if (def.nullable === false) {
    parts.push("not null");
  }

  // Default value
  if (def.default !== undefined) {
    if (typeof def.default === "string" && def.default.includes("(")) {
      // It's a function call like now()
      parts.push(`default ${def.default}`);
    } else if (typeof def.default === "string") {
      parts.push(`default '${def.default}'`);
    } else if (typeof def.default === "boolean") {
      parts.push(`default ${def.default}`);
    } else {
      parts.push(`default ${def.default}`);
    }
  }

  // Unique
  if (def.unique) {
    parts.push("unique");
  }

  // References (foreign key)
  if (def.references) {
    parts.push(`references ${def.references}`);
  }

  return parts.join(" ");
}

/**
 * Checks if a schema entry is an extended table schema
 */
function isExtendedSchema(
  schema: string | ExtendedTableSchema | any[]
): schema is ExtendedTableSchema {
  return (
    typeof schema === "object" &&
    !Array.isArray(schema) &&
    ("columns" in schema || "supabase" in schema)
  );
}

/**
 * Generates SQL migration for creating Supabase tables from Localbase schema
 *
 * @param schema - The Localbase schema definition
 * @param tableMapping - Optional mapping of local table names to Supabase table names
 * @param options - Generation options
 * @returns SQL migration string
 */
export function generateSupabaseMigration(
  schema: TableSchema | Record<string, ExtendedTableSchema>,
  tableMapping?: Record<string, string>,
  options: {
    enableRLS?: boolean;
    includeTimestamps?: boolean;
    includePolicies?: boolean;
    schemaName?: string;
  } = {}
): string {
  const {
    enableRLS = true,
    includeTimestamps = true,
    includePolicies = false,
    schemaName = "public",
  } = options;

  const migrations: string[] = [];
  migrations.push("-- Generated by Localbase Schema Generator");
  migrations.push(`-- Generated at: ${new Date().toISOString()}`);
  migrations.push("");

  for (const [localName, tableSchema] of Object.entries(schema)) {
    const supabaseTableName = tableMapping?.[localName] || localName;
    const fullTableName = `${schemaName}.${supabaseTableName}`;

    if (isExtendedSchema(tableSchema)) {
      // Use the extended schema with column definitions
      const columns = tableSchema.columns || tableSchema.supabase;

      if (!columns) {
        migrations.push(`-- Skipping ${localName}: no column definitions`);
        continue;
      }

      const columnDefs: string[] = [];

      for (const [colName, colDef] of Object.entries(columns)) {
        columnDefs.push("  " + generateColumnDef(colName, colDef));
      }

      // Add timestamps if requested and not already present
      if (includeTimestamps) {
        if (!("updated_at" in columns)) {
          columnDefs.push('  "updated_at" timestamptz default now() not null');
        }
      }

      migrations.push(`-- Table: ${supabaseTableName}`);
      migrations.push(`CREATE TABLE IF NOT EXISTS ${fullTableName} (`);
      migrations.push(columnDefs.join(",\n"));
      migrations.push(");");
      migrations.push("");

      // Create updated_at trigger if timestamps are enabled
      if (includeTimestamps) {
        migrations.push(`-- Auto-update updated_at timestamp`);
        migrations.push(
          `CREATE OR REPLACE FUNCTION ${schemaName}.update_updated_at_column()`
        );
        migrations.push(`RETURNS TRIGGER AS $$`);
        migrations.push(`BEGIN`);
        migrations.push(`  NEW.updated_at = now();`);
        migrations.push(`  RETURN NEW;`);
        migrations.push(`END;`);
        migrations.push(`$$ language 'plpgsql';`);
        migrations.push("");
        migrations.push(
          `DROP TRIGGER IF EXISTS update_${supabaseTableName}_updated_at ON ${fullTableName};`
        );
        migrations.push(
          `CREATE TRIGGER update_${supabaseTableName}_updated_at`
        );
        migrations.push(`  BEFORE UPDATE ON ${fullTableName}`);
        migrations.push(`  FOR EACH ROW`);
        migrations.push(
          `  EXECUTE FUNCTION ${schemaName}.update_updated_at_column();`
        );
        migrations.push("");
      }

      // Enable RLS
      if (enableRLS) {
        migrations.push(`-- Enable Row Level Security`);
        migrations.push(
          `ALTER TABLE ${fullTableName} ENABLE ROW LEVEL SECURITY;`
        );
        migrations.push("");
      }

      // Add example policies if requested
      if (includePolicies) {
        migrations.push(`-- Example RLS Policies (customize as needed)`);
        migrations.push(`-- Allow authenticated users to read all rows`);
        migrations.push(
          `CREATE POLICY "Enable read access for authenticated users" ON ${fullTableName}`
        );
        migrations.push(`  FOR SELECT`);
        migrations.push(`  TO authenticated`);
        migrations.push(`  USING (true);`);
        migrations.push("");
        migrations.push(`-- Allow users to insert their own rows`);
        migrations.push(
          `CREATE POLICY "Enable insert for authenticated users" ON ${fullTableName}`
        );
        migrations.push(`  FOR INSERT`);
        migrations.push(`  TO authenticated`);
        migrations.push(`  WITH CHECK (true);`);
        migrations.push("");
        migrations.push(`-- Allow users to update their own rows`);
        migrations.push(
          `CREATE POLICY "Enable update for authenticated users" ON ${fullTableName}`
        );
        migrations.push(`  FOR UPDATE`);
        migrations.push(`  TO authenticated`);
        migrations.push(`  USING (true);`);
        migrations.push("");
        migrations.push(`-- Allow users to delete their own rows`);
        migrations.push(
          `CREATE POLICY "Enable delete for authenticated users" ON ${fullTableName}`
        );
        migrations.push(`  FOR DELETE`);
        migrations.push(`  TO authenticated`);
        migrations.push(`  USING (true);`);
        migrations.push("");
      }
    } else {
      // Legacy string schema format - generate placeholder
      migrations.push(`-- Table: ${supabaseTableName}`);
      migrations.push(
        `-- Note: Using legacy schema format. Define columns manually or use extended schema format.`
      );
      migrations.push(`-- Schema definition: ${JSON.stringify(tableSchema)}`);
      migrations.push(`-- CREATE TABLE ${fullTableName} (...);`);
      migrations.push("");
    }
  }

  return migrations.join("\n");
}

/**
 * Generates a TypeScript interface from an extended schema definition
 */
export function generateTypeScriptInterface(
  tableName: string,
  schema: ExtendedTableSchema
): string {
  const columns = schema.columns || schema.supabase;
  if (!columns) return "";

  const lines: string[] = [];
  lines.push(`export interface ${capitalize(tableName)} {`);

  for (const [colName, colDef] of Object.entries(columns)) {
    const tsType = getTypeScriptType(colDef);
    const optional = typeof colDef === "object" && colDef.nullable ? "?" : "";
    lines.push(`  ${colName}${optional}: ${tsType};`);
  }

  lines.push("}");
  return lines.join("\n");
}

function getTypeScriptType(def: ColumnDefinition | string): string {
  if (typeof def === "string") {
    // Parse raw SQL type
    const lower = def.toLowerCase();
    if (lower.includes("text") || lower.includes("varchar")) return "string";
    if (lower.includes("boolean")) return "boolean";
    if (
      lower.includes("int") ||
      lower.includes("numeric") ||
      lower.includes("decimal")
    )
      return "number";
    if (lower.includes("timestamp") || lower.includes("date")) return "Date";
    if (lower.includes("uuid")) return "string";
    if (lower.includes("jsonb") || lower.includes("json")) return "unknown";
    return "unknown";
  }

  const typeMap: Record<string, string> = {
    string: "string",
    text: "string",
    varchar: "string",
    uuid: "string",
    number: "number",
    integer: "number",
    bigint: "number",
    numeric: "number",
    decimal: "number",
    boolean: "boolean",
    date: "Date",
    timestamp: "Date",
    timestamptz: "Date",
    json: "unknown",
    jsonb: "unknown",
    array: "unknown[]",
  };

  return typeMap[def.type.toLowerCase()] || "unknown";
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Validates that a schema has all required fields for Supabase sync
 */
export function validateSchemaForSync(
  schema: TableSchema | Record<string, ExtendedTableSchema>
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  for (const [tableName, tableSchema] of Object.entries(schema)) {
    if (isExtendedSchema(tableSchema)) {
      const columns = tableSchema.columns || tableSchema.supabase;

      if (!columns) {
        errors.push(`Table '${tableName}' has no column definitions`);
        continue;
      }

      // Check for primary key
      const hasPrimaryKey = Object.entries(columns).some(([_, def]) => {
        if (typeof def === "string") {
          return def.toLowerCase().includes("primary key");
        }
        return def.primaryKey;
      });

      if (!hasPrimaryKey) {
        errors.push(`Table '${tableName}' has no primary key defined`);
      }

      // Check for id column (recommended)
      if (!("id" in columns)) {
        errors.push(
          `Table '${tableName}' has no 'id' column (recommended for sync)`
        );
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
